<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LangChain.Core</name>
    </assembly>
    <members>
        <member name="T:LangChain.Base.BaseCallbackHandler">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.Name">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreLlm">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreRetry">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreChain">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreAgent">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreRetriever">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseCallbackHandler.IgnoreChatModel">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.#ctor(LangChain.Base.IBaseCallbackHandlerInput)">
            <summary>
            
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleLlmStartAsync(LangChain.LLMS.BaseLlm,System.String[],System.String,System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleLlmNewTokenAsync(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleLlmErrorAsync(System.Exception,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleLlmEndAsync(LangChain.Schema.LlmResult,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleChatModelStartAsync(LangChain.LLMS.BaseLlm,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.List{LangChain.Providers.Message}},System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleChainStartAsync(LangChain.Abstractions.Chains.Base.IChain,System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleChainErrorAsync(System.Exception,System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleChainEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleToolStartAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleToolErrorAsync(System.Exception,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleToolEndAsync(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleTextAsync(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleAgentActionAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleAgentEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleRetrieverStartAsync(LangChain.Retrievers.BaseRetriever,System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleRetrieverEndAsync(System.String,System.Collections.Generic.List{LangChain.Docstore.Document},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseCallbackHandler.HandleRetrieverErrorAsync(System.Exception,System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Base.BaseChain">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseChain.#ctor(LangChain.Base.IChainInputs)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseChain.ChainType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:LangChain.Base.BaseChain.InputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseChain.OutputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseChain.Run(System.String)">
            <summary>
            Run the chain using a simple input/output.
            </summary>
            <param name="input">The string input to use to execute the chain.</param>
            <returns>A text value containing the result of the chain.</returns>
            <exception cref="T:System.ArgumentException">If the type of chain used expects multiple inputs, this method will throw an ArgumentException.</exception>
        </member>
        <member name="M:LangChain.Base.BaseChain.Run(System.Collections.Generic.Dictionary{System.String,System.Object},LangChain.Callback.ICallbacks)">
            <summary>
            Run the chain using a simple input/output.
            </summary>
            <param name="input">The dict input to use to execute the chain.</param>
            <param name="callbacks">
            Callbacks to use for this chain run. These will be called in
            addition to callbacks passed to the chain during construction, but only
            these runtime callbacks will propagate to calls to other objects.
            </param>
            <returns>A text value containing the result of the chain.</returns>
        </member>
        <member name="M:LangChain.Base.BaseChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.ICallbacks,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Execute the chain, using the values provided.
            </summary>
            <param name="values">The <see cref="T:LangChain.Schema.ChainValues"/> to use.</param>
            <param name="callbacks"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.BaseChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Execute the chain, using the values provided.
            </summary>
            <param name="values">The <see cref="T:LangChain.Schema.ChainValues"/> to use.</param>
            <param name="runManager"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.BaseChain.ApplyAsync(System.Collections.Generic.IReadOnlyList{LangChain.Schema.ChainValues})">
            <summary>
            Call the chain on all inputs in the list.
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseChain.Deserialize(LangChain.Chains.SerializedBaseChain,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:LangChain.Base.IBaseChainInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseChainInput.Callbacks">
            <summary>
            Optional list of callback handlers (or callback manager). Defaults to None.
            Callback handlers are called throughout the lifecycle of a call to a chain,
            starting with on_chain_start, ending with on_chain_end or on_chain_error.
            Each custom chain can optionally call additional callback methods, see Callback docs
            for full details.
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseChainInput.Verbose">
            <summary>
            Whether or not run in verbose mode. In verbose mode, some intermediate logs
            will be printed to the console. 
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseChainInput.Tags">
            <summary>
            Optional list of tags associated with the chain. Defaults to None.
            These tags will be associated with each call to this chain,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a chain with its use case.
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseChainInput.Metadata">
            <summary>
            Optional metadata associated with the chain. Defaults to None.
            This metadata will be associated with each call to this chain,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a chain with its use case.
            </summary>
        </member>
        <member name="T:LangChain.Base.BaseLangChain">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.BaseLangChain.Verbose">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseLangChain.#ctor(LangChain.Base.IBaseLangChainParams)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="T:LangChain.Base.BaseLanguageModel">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.BaseLanguageModel.#ctor(LangChain.Base.IBaseLanguageModelParams)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="P:LangChain.Base.BaseLanguageModel.ModelType">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.BaseLanguageModel.LlmType">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseLanguageModel.GeneratePrompt(LangChain.Schema.BasePromptValue[],System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            
            </summary>
            <param name="promptValues"></param>
            <param name="stopSequences"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Base.BaseLoader">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.BaseLoader.Load">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.BaseLoader.LoadAndSplit(LangChain.Splitters.Text.TextSplitter)">
            <summary>
            
            </summary>
            <param name="textSplitter"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.BaseLoader.LazyLoad">
            <summary>
            
            </summary>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:LangChain.Base.ChainInputs">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.ChainInputs.Callbacks">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.ChainInputs.Tags">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.ChainInputs.Metadata">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.ChainInputs.Verbose">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Base.Handler">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Handler.#ctor(LangChain.Base.IBaseCallbackHandlerInput)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Base.IBaseCallbackHandler">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandler.Name">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleLlmStartAsync(LangChain.LLMS.BaseLlm,System.String[],System.String,System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleLlmNewTokenAsync(System.String,System.String,System.String)">
            <summary>
            Run on new LLM token. Only available when streaming is enabled.
            </summary>
            <param name="token"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleLlmErrorAsync(System.Exception,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="err"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleLlmEndAsync(LangChain.Schema.LlmResult,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleChatModelStartAsync(LangChain.LLMS.BaseLlm,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.List{LangChain.Providers.Message}},System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="llm"></param>
            <param name="messages"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleChainStartAsync(LangChain.Abstractions.Chains.Base.IChain,System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="chain"></param>
            <param name="inputs"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <param name="runType"></param>
            <param name="name"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleChainErrorAsync(System.Exception,System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            
            </summary>
            <param name="err"></param>
            <param name="runId"></param>
            <param name="inputs"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleChainEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleToolStartAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="tool"></param>
            <param name="input"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <param name="runType"></param>
            <param name="name"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleToolErrorAsync(System.Exception,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="err"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleToolEndAsync(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleTextAsync(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleAgentActionAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleAgentEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleRetrieverStartAsync(LangChain.Retrievers.BaseRetriever,System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="retriever"></param>
            <param name="query"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <param name="runType"></param>
            <param name="name"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleRetrieverEndAsync(System.String,System.Collections.Generic.List{LangChain.Docstore.Document},System.String,System.String)">
            <summary>
            
            </summary>
            <param name="query"></param>
            <param name="documents"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.IBaseCallbackHandler.HandleRetrieverErrorAsync(System.Exception,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="exception"></param>
            <param name="query"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Base.IBaseCallbackHandlerInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreLlm">
            <summary> Whether to ignore LLM callbacks. </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreRetry">
            <summary> Whether to ignore retry callbacks. </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreChain">
            <summary> Whether to ignore chain callbacks. </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreAgent">
            <summary> Whether to ignore agent callbacks. </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreRetriever">
            <summary> Whether to ignore retriever callbacks. </summary>
        </member>
        <member name="P:LangChain.Base.IBaseCallbackHandlerInput.IgnoreChatModel">
            <summary> Whether to ignore chat model callbacks. </summary>
        </member>
        <member name="T:LangChain.Base.IBaseLangChainParams">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.IBaseLangChainParams.Verbose">
            <summary>
            Whether or not run in verbose mode. In verbose mode, some intermediate logs
            will be printed to the console. 
            </summary>
        </member>
        <member name="T:LangChain.Base.IBaseLanguageModelCallOptions">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Base.IBaseLanguageModelParams">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.IBaseLanguageModelParams.ApiKey">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Base.IChainInputs">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.IChainInputs.Callbacks">
            <summary>
            Optional list of callback handlers (or callback manager). Defaults to None.
            Callback handlers are called throughout the lifecycle of a call to a chain,
            starting with on_chain_start, ending with on_chain_end or on_chain_error.
            Each custom chain can optionally call additional callback methods, see Callback docs
            for full details.
            </summary>
        </member>
        <member name="P:LangChain.Base.IChainInputs.Tags">
            <summary>
            Optional list of tags associated with the chain. Defaults to None.
            These tags will be associated with each call to this chain,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a chain with its use case.
            </summary>
        </member>
        <member name="P:LangChain.Base.IChainInputs.Metadata">
            <summary>
            Optional metadata associated with the chain. Defaults to None.
            This metadata will be associated with each call to this chain,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a chain with its use case.
            </summary>
        </member>
        <member name="T:LangChain.Base.ISource">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.ISource.LoadAsync(System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="T:LangChain.Base.TextSplitterExtensions">
            <summary>
            Functionality for splitting text.
            <remarks>
            - ported from langchain/text_splitter.py
            
            </remarks>
            </summary>
        </member>
        <member name="M:LangChain.Base.TextSplitterExtensions.CreateDocuments(LangChain.Splitters.Text.TextSplitter,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Create documents from a list of texts.
            </summary>
            <exception cref="T:System.ArgumentException">
            If the number of texts and metadata(when not null) are not equal, this method will throw an ArgumentException.
            </exception>
        </member>
        <member name="M:LangChain.Base.TextSplitterExtensions.SplitDocuments(LangChain.Splitters.Text.TextSplitter,System.Collections.Generic.IReadOnlyCollection{LangChain.Docstore.Document})">
            <summary>
            
            </summary>
            <param name="splitter"></param>
            <param name="documents"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Base.Tracers.BaseCallbackHandlerInput">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreLlm">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreRetry">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreChain">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreAgent">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreRetriever">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.BaseCallbackHandlerInput.IgnoreChatModel">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Base.Tracers.BaseTracer">
            <summary>
            Base class for tracers.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.#ctor(LangChain.Base.IBaseCallbackHandlerInput)">
            <summary>
            Base class for tracers.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.BaseTracer.RunMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.PersistRun(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmStartAsync(LangChain.LLMS.BaseLlm,System.String[],System.String,System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmErrorAsync(System.Exception,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmEndAsync(LangChain.Schema.LlmResult,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmNewTokenAsync(System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChatModelStartAsync(LangChain.LLMS.BaseLlm,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.List{LangChain.Providers.Message}},System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainStartAsync(LangChain.Abstractions.Chains.Base.IChain,System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainErrorAsync(System.Exception,System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Handle an error for a chain run.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            End a trace for a chain run.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolStartAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolErrorAsync(System.Exception,System.String,System.String)">
            <summary>
            Handle an error for a tool run.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolEndAsync(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <exception cref="T:LangChain.Base.Tracers.TracerException"></exception>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverStartAsync(LangChain.Retrievers.BaseRetriever,System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Run when Retriever starts running.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverEndAsync(System.String,System.Collections.Generic.List{LangChain.Docstore.Document},System.String,System.String)">
            <summary>
            Run when Retriever ends running.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverErrorAsync(System.Exception,System.String,System.String,System.String)">
            <summary>
            Run when Retriever errors.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleTextAsync(System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleAgentActionAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleAgentEndAsync(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.OnRunCreate(LangChain.Base.Tracers.Run)">
            <summary>
            Process a run upon creation.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.OnRunUpdate(LangChain.Base.Tracers.Run)">
            <summary>
            Process a run upon update.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmStartAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmNewTokenAsync(LangChain.Base.Tracers.Run,System.String)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmErrorAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleLlmEndAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChatModelStartAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainStartAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainErrorAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleChainEndAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolStartAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolErrorAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleToolEndAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleTextAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleAgentActionAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleAgentEndAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverStartAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverEndAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.HandleRetrieverErrorAsync(LangChain.Base.Tracers.Run)">
            <summary>
            
            </summary>
            <param name="run"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Base.Tracers.BaseTracer.AddChildRun(LangChain.Base.Tracers.Run,LangChain.Base.Tracers.Run)">
            <summary>
            Add child run to a chain run or tool run.
            </summary>
            <param name="parentRun"></param>
            <param name="childRun"></param>
        </member>
        <member name="T:LangChain.Base.Tracers.ConsoleCallbackHandlerInput">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Base.Tracers.ConsoleCallbackHandler">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.#ctor(LangChain.Base.Tracers.ConsoleCallbackHandlerInput)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.#ctor">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Base.Tracers.ConsoleCallbackHandler.Name">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.PersistRun(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleLlmStartAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleLlmNewTokenAsync(LangChain.Base.Tracers.Run,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleLlmErrorAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleLlmEndAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleChatModelStartAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleChainStartAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleChainErrorAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleChainEndAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleToolStartAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleToolErrorAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleToolEndAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleTextAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleAgentActionAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleAgentEndAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleRetrieverStartAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleRetrieverEndAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.HandleRetrieverErrorAsync(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.OnRunCreate(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.OnRunUpdate(LangChain.Base.Tracers.Run)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Base.Tracers.ConsoleCallbackHandler.Elapsed(LangChain.Base.Tracers.Run)">
            <summary>
            Get the elapsed time of a run.
            </summary>
            <returns>A string with the elapsed time in seconds or milliseconds if time is less than a second.</returns>
        </member>
        <member name="T:LangChain.Base.Tracers.RunBase">
            <summary>
            Base Run schema.
            Contains the fundamental fields to define a run in a system.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Id">
            <summary>
            Unique identifier for the run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Name">
            <summary>
            Human-readable name for the run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.StartTime">
            <summary>
            Start time of the run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.RunType">
            <summary>
            The type of run, such as tool, chain, llm, retriever,
            embedding, prompt, parser.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.EndTime">
            <summary>
            End time of the run, if applicable.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.ExtraData">
            <summary>
            Additional metadata or settings related to the run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Error">
            <summary>
            Error message, if the run encountered any issues.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Serialized">
            <summary>
            Serialized object that executed the run for potential reuse.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Events">
            <summary>
            List of events associated with the run, like start and end events.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Inputs">
            <summary>
            Inputs used for the run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Outputs">
            <summary>
            Outputs generated by the run, if any.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.ReferenceExampleId">
            <summary>
            Reference to an example that this run may be based on.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.ParentRunId">
            <summary>
            Identifier for a parent run, if this run is a sub-run.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.RunBase.Tags">
            <summary>
            Tags for categorizing or annotating the run.
            </summary>
        </member>
        <member name="T:LangChain.Base.Tracers.Run">
            <summary>
            Run schema in the Tracer
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.Run.ExecutionOrder">
            <summary>
            The execution order of the run within a run trace.
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.Run.ChildExecutionOrder">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Base.Tracers.Run.ChildRuns">
            <summary>
            The child runs of this run
            </summary>
        </member>
        <member name="T:LangChain.Base.Tracers.RunExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Base.Tracers.StringExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.StringExtensions.Capitalize(System.String)">
            <summary>
            
            </summary>
            <param name="word"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Base.Tracers.TracerException">
            <summary>
            Base class for exceptions in tracers module.
            </summary>
        </member>
        <member name="M:LangChain.Base.Tracers.TracerException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.TracerException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Base.Tracers.TracerException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Cache.BaseCache">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Callback.BaseRunManager">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.RunId">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.Handlers">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.InheritableHandlers">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.ParentRunId">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.Tags">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.InheritableTags">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.Metadata">
            <summary> </summary>
        </member>
        <member name="P:LangChain.Callback.BaseRunManager.InheritableMetadata">
            <summary> </summary>
        </member>
        <member name="M:LangChain.Callback.BaseRunManager.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="runId"></param>
            <param name="handlers"></param>
            <param name="inheritableHandlers"></param>
            <param name="parentRunId"></param>
            <param name="tags"></param>
            <param name="inheritableTags"></param>
            <param name="metadata"></param>
            <param name="inheritableMetadata"></param>
        </member>
        <member name="M:LangChain.Callback.BaseRunManager.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.BaseRunManager.HandleText(System.String)">
            <summary>
            Run when text is received.
            </summary>
            <param name="text">The received text.</param>
        </member>
        <member name="M:LangChain.Callback.BaseRunManager.GetNoopManager``1">
            <summary>
            Return a manager that doesn't perform any operations.
            TODO: (static abstract not supported by some target runtimes)
            </summary>
        </member>
        <member name="T:LangChain.Callback.IRunManagerImplementation`1">
            <summary>
            
            </summary>
            <typeparam name="TThis"></typeparam>
        </member>
        <member name="T:LangChain.Callback.CallbackManager">
            <summary>
            Base callback manager that handles callbacks from LangChain.
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.Handlers">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.InheritableHandlers">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.ParentRunId">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.Tags">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.InheritableTags">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.Metadata">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.CallbackManager.InheritableMetadata">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.#ctor(System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            
            </summary>
            <param name="inheritableMetadata"></param>
            <param name="parentRunId"></param>
            <param name="handlers"></param>
            <param name="inheritableHandlers"></param>
            <param name="tags"></param>
            <param name="inheritableTags"></param>
            <param name="metadata"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.AddTags(System.Collections.Generic.IReadOnlyList{System.String},System.Boolean)">
            <summary>
            
            </summary>
            <param name="tags"></param>
            <param name="inherit"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.RemoveTags(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            
            </summary>
            <param name="tags"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.AddMetadata(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.Boolean)">
            <summary>
            
            </summary>
            <param name="metadata"></param>
            <param name="inherit"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.RemoveMetadata(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.HandleLlmStart(LangChain.LLMS.BaseLlm,System.Collections.Generic.IReadOnlyList{System.String},System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="llm"></param>
            <param name="prompts"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.HandleChatModelStart(LangChain.LLMS.BaseLlm,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.List{LangChain.Providers.Message}},System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="llm"></param>
            <param name="messages"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.HandleChainStart(LangChain.Base.BaseChain,LangChain.Abstractions.Schema.IChainValues,System.String)">
            <summary>
            
            </summary>
            <param name="chain"></param>
            <param name="inputs"></param>
            <param name="runId"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.HandleRetrieverStart(LangChain.Retrievers.BaseRetriever,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="retriever"></param>
            <param name="query"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <param name="extraParams"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.AddHandler(LangChain.Base.BaseCallbackHandler,System.Boolean)">
            <summary>
            
            </summary>
            <param name="handler"></param>
            <param name="inherit"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.RemoveHandler(LangChain.Base.BaseCallbackHandler)">
            <summary>
            
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.SetHandlers(System.Collections.Generic.IEnumerable{LangChain.Base.BaseCallbackHandler})">
            <summary>
            
            </summary>
            <param name="handlers"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.SetHandlers(System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Boolean)">
            <summary>
            
            </summary>
            <param name="handlers"></param>
            <param name="inherit"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.Copy(System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Boolean)">
            <summary>
            
            </summary>
            <param name="additionalHandlers"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.FromHandlers(System.Collections.Generic.List{LangChain.Base.Handler})">
            <summary>
            
            </summary>
            <param name="handlers"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManager.Configure(LangChain.Callback.ICallbacks,LangChain.Callback.ICallbacks,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="inheritableCallbacks"></param>
            <param name="localCallbacks"></param>
            <param name="verbose"></param>
            <param name="localTags"></param>
            <param name="inheritableTags"></param>
            <param name="localMetadata"></param>
            <param name="inheritableMetadata"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Callback.CallbackManagerForChainRun">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForChainRun.#ctor">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForChainRun.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForChainRun.HandleChainEndAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Abstractions.Schema.IChainValues)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForChainRun.HandleChainErrorAsync(System.Exception,LangChain.Abstractions.Schema.IChainValues)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="input"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForChainRun.HandleTextAsync(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:LangChain.Callback.CallbackManagerForLlmRun">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForLlmRun.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForLlmRun.HandleLlmNewTokenAsync(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForLlmRun.HandleLlmErrorAsync(System.Exception,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForLlmRun.HandleLlmEndAsync(LangChain.Schema.LlmResult,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
        </member>
        <member name="T:LangChain.Callback.CallbackManagerForRetrieverRun">
            <summary>
            Callback manager for retriever run.
            </summary>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForRetrieverRun.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForRetrieverRun.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForRetrieverRun.HandleRetrieverEndAsync(System.String,System.Collections.Generic.IReadOnlyCollection{LangChain.Docstore.Document})">
            <summary>
            Run when retriever ends running.
            </summary>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForRetrieverRun.HandleRetrieverErrorAsync(System.Exception,System.String)">
            <summary>
            Run when retriever errors.
            </summary>
        </member>
        <member name="T:LangChain.Callback.CallbackManagerForToolRun">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForToolRun.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForToolRun.HandleToolErrorAsync(System.Exception,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="err"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:LangChain.Callback.CallbackManagerForToolRun.HandleToolEndAsync(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="runId"></param>
            <param name="parentRunId"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:LangChain.Callback.CallbackManagerMethod">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Callback.ICallbackManagerOptions">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.ICallbackManagerOptions.Verbose">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Callback.ICallbackManagerOptions.Tracing">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Callback.ICallbacks">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Callback.ManagerCallbacksExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Callback.ManagerCallbacksExtensions.ToCallbacks(LangChain.Callback.ParentRunManager)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:LangChain.Callback.ManagerCallbacks">
            <summary>
            
            </summary>
            <param name="Value"></param>
        </member>
        <member name="M:LangChain.Callback.ManagerCallbacks.#ctor(LangChain.Callback.CallbackManager)">
            <summary>
            
            </summary>
            <param name="Value"></param>
        </member>
        <member name="P:LangChain.Callback.ManagerCallbacks.Value">
            <summary></summary>
        </member>
        <member name="T:LangChain.Callback.HandlersCallbacks">
            <summary>
            
            </summary>
            <param name="Value"></param>
        </member>
        <member name="M:LangChain.Callback.HandlersCallbacks.#ctor(System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler})">
            <summary>
            
            </summary>
            <param name="Value"></param>
        </member>
        <member name="P:LangChain.Callback.HandlersCallbacks.Value">
            <summary></summary>
        </member>
        <member name="T:LangChain.Callback.ParentRunManager">
            <summary>
            Sync Parent Run Manager.
            </summary>
        </member>
        <member name="M:LangChain.Callback.ParentRunManager.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.ParentRunManager.#ctor(System.String,System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.Collections.Generic.List{LangChain.Base.BaseCallbackHandler},System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Callback.ParentRunManager.GetChild(System.String)">
            <summary>
            Get a child callback manager.
            </summary>
            <param name="tag">The tag for the child callback manager.</param>
            <returns>The child callback manager.</returns>
        </member>
        <member name="T:LangChain.Abstractions.Chains.Base.IChain">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Abstractions.Chains.Base.IChain.InputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Abstractions.Chains.Base.IChain.OutputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Abstractions.Chains.Base.IChain.Run(System.String)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Abstractions.Chains.Base.IChain.Run(System.Collections.Generic.Dictionary{System.String,System.Object},LangChain.Callback.ICallbacks)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="callbacks"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Abstractions.Chains.Base.IChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.ICallbacks,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="values"></param>
            <param name="callbacks"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Abstractions.Schema.IChainValues">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Abstractions.Schema.IChainValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Abstractions.Schema.IInputValues">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Abstractions.Schema.IInputValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Abstractions.Schema.IPromptValue">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.Chain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.Chain.Template(System.String,System.String)">
            <summary>
            Replaces context and question in the prompt with their values.
            </summary>
            <param name="template"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.Set(System.Object,System.String)">
            <summary>
            Sets the value to the context.
            </summary>
            <param name="value"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.Set(System.Func{System.String},System.String)">
            <summary>
            
            </summary>
            <param name="valueGetter"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.Do(System.Action{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.LLM(LangChain.Providers.IChatModel,System.String,System.String)">
            <summary>
            Sends the result to the language model.
            </summary>
            <param name="llm"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.LargeLanguageModel(LangChain.Providers.IChatModel,System.String,System.String)">
            <inheritdoc cref="M:LangChain.Chains.Chain.LLM(LangChain.Providers.IChatModel,System.String,System.String)"/>
        </member>
        <member name="M:LangChain.Chains.Chain.RetrieveDocuments(LangChain.Indexes.VectorStoreIndexWrapper,System.Int32,System.String,System.String)">
            <inheritdoc cref="M:LangChain.Chains.Chain.RetrieveSimilarDocuments(LangChain.Indexes.VectorStoreIndexWrapper,System.Int32,System.String,System.String)"/>
        </member>
        <member name="M:LangChain.Chains.Chain.RetrieveSimilarDocuments(LangChain.Indexes.VectorStoreIndexWrapper,System.Int32,System.String,System.String)">
            <summary>
            Takes most similar documents.
            </summary>
            <param name="index"></param>
            <param name="amount"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.StuffDocuments(System.String,System.String)">
            <inheritdoc cref="M:LangChain.Chains.Chain.CombineDocuments(System.String,System.String)"/>
        </member>
        <member name="M:LangChain.Chains.Chain.CombineDocuments(System.String,System.String)">
            <summary>
            Combines documents together and put them into context
            </summary>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.UpdateMemory(LangChain.Memory.BaseChatMemory,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="memory"></param>
            <param name="requestKey"></param>
            <param name="responseKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.TTS(LangChain.Providers.ITextToSpeechModel,LangChain.Providers.TextToSpeechSettings,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="settings"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.STT(LangChain.Providers.ISpeechToTextModel,LangChain.Providers.SpeechToTextSettings,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="settings"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.ReActAgentExecutor(LangChain.Providers.IChatModel,System.String,System.Int32,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="reActPrompt"></param>
            <param name="maxActions"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.ReActParser(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.GroupChat(System.Collections.Generic.IList{LangChain.Chains.StackableChains.Agents.AgentExecutorChain},System.String,System.Int32,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="agents"></param>
            <param name="stopPhrase"></param>
            <param name="messagesLimit"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.GenerateImage(LangChain.Providers.IImageGenerationModel,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.SaveIntoFile(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="inputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.Chain.Crew(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.CrewAgent},LangChain.Chains.StackableChains.Agents.Crew.CrewAgent,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="allAgents"></param>
            <param name="manager"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain">
            <summary>
            
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain.#ctor(LangChain.Chains.CombineDocuments.AnalyzeDocumentsChainInput)">
            <summary>
            
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.AnalyzeDocumentChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.AnalyzeDocumentsChainInput">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.AnalyzeDocumentsChainInput.#ctor(LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.AnalyzeDocumentsChainInput.CombineDocumentsChain">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.AnalyzeDocumentsChainInput.Splitter">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain">
            <summary>
            Base interface for chains combining documents.
            
            Subclasses of this chain deal with combining documents in a variety of
            ways. This base class exists to add some uniformity in the interface these types
            of chains should expose. Namely, they expect an input key related to the documents
            to use (default `input_documents`), and then also expose a method to calculate
            the length of a prompt from documents (useful for outside callers to use to
            determine whether it's safe to pass a list of documents into this chain or whether
            that will longer than the context length).
            </summary>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.#ctor(LangChain.Chains.CombineDocuments.BaseCombineDocumentsChainInput)">
            <summary>
            Base interface for chains combining documents.
            
            Subclasses of this chain deal with combining documents in a variety of
            ways. This base class exists to add some uniformity in the interface these types
            of chains should expose. Namely, they expect an input key related to the documents
            to use (default `input_documents`), and then also expose a method to calculate
            the length of a prompt from documents (useful for outside callers to use to
            determine whether it's safe to pass a list of documents into this chain or whether
            that will longer than the context length).
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.InputKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.OutputKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Prepare inputs, call combine docs, prepare outputs.
            </summary>
            <param name="values"></param>
            <param name="runManager"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.PromptLength(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Return the prompt length given the documents passed in.
            
            This can be used by a caller to determine whether passing in a list
            of documents would exceed a certain prompt length. This useful when
            trying to ensure that the size of a prompt remains below a certain
            context limit.
            </summary>
            <param name="docs">a list of documents to use to calculate the total prompt length.</param>
            <param name="otherKeys"></param>
            <returns>Returns null if the method does not depend on the prompt length, otherwise the length of the prompt in tokens.</returns>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain.CombineDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Combine documents into a single string.
            </summary>
            <param name="docs">the documents to combine</param>
            <param name="otherKeys"></param>
            <returns>The first element returned is the single string output. The second element returned is a dictionary of other keys to return.</returns>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChainInput">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChainInput.InputKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.BaseCombineDocumentsChainInput.OutputKey">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain">
            <summary>
            Combining documents by mapping a chain over them, then combining results.
            
            We first call <see cref="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.LlmChain"/> on each document individually, passing in the
            <see cref="P:LangChain.Docstore.Document.PageContent"/> and any other keys. This is the `map` step.
            
            We then process the results of that `map` step in a `reduce` step. This should
            be done by a <see cref="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.ReduceDocumentsChain"/>.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.LlmChain">
            <summary>
            Chain to apply to each document individually.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.ReduceDocumentsChain">
            <summary>
            Chain to use to reduce the results of applying `llm_chain` to each doc.
            This typically either a ReduceDocumentChain or StuffDocumentChain.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.DocumentVariableName">
            <summary>
            The variable name in the llm_chain to put the documents in.
            If only one variable in the llm_chain, this need not be provided.
            </summary>
            <returns></returns>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.ReturnIntermediateSteps">
            <summary>
            Return the results of the map steps in the output.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.#ctor(LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.PromptLength(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.MapReduceDocumentsChain.CombineDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Combine documents in a map reduce manner.
            
            Combine by mapping first chain over all documents, then reducing the results.
            This reducing can be done recursively if needed (if there are many documents).
            </summary>
            <param name="docs"></param>
            <param name="otherKeys"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput.LlmChain">
            <summary>
            Chain to apply to each document individually.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput.ReduceDocumentsChain">
            <summary>
            Chain to use to reduce the results of applying `llm_chain` to each doc.
            This typically either a ReduceDocumentChain or StuffDocumentChain.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput.DocumentVariableName">
            <summary>
            The variable name in the llm_chain to put the documents in.
            If only one variable in the llm_chain, this need not be provided.
            </summary>
            <returns></returns>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.MapReduceDocumentsChainInput.ReturnIntermediateSteps">
            <summary>
            Return the results of the map steps in the output.
            </summary>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.ReduceDocumentsChain">
            <summary>
            Combine documents by recursively reducing them.
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CombineDocumentsChain"/> is ALWAYS provided. This is final chain that is called.
            We pass all previous results to this chain, and the output of this chain is
            returned as a final result.
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CollapseDocumentsChain"/> is used if the documents passed in are too many to all
            be passed to <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CombineDocumentsChain"/> in one go. In this case,
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CollapseDocumentsChain"/> is called recursively on as big of groups of documents
            as are allowed.
            </summary>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.#ctor(LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput)">
            <summary>
            Combine documents by recursively reducing them.
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CombineDocumentsChain"/> is ALWAYS provided. This is final chain that is called.
            We pass all previous results to this chain, and the output of this chain is
            returned as a final result.
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CollapseDocumentsChain"/> is used if the documents passed in are too many to all
            be passed to <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CombineDocumentsChain"/> in one go. In this case,
            <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CollapseDocumentsChain"/> is called recursively on as big of groups of documents
            as are allowed.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.PromptLength(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.CombineDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Combine multiple documents recursively.
            </summary>
            <param name="docs">List of documents to combine, assumed that each one is less than <see cref="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.TokenMax"/>.</param>
            <param name="otherKeys">additional parameters to be passed to LLM calls (like other input variables besides the documents)</param>
            <returns>
            The first element returned is the single string output.
            The second element returned is a dictionary of other keys to return.
            </returns>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.SplitListOfDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Nullable{System.Int32},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Split Documents into subsets that each meet a cumulative length constraint.
            </summary>
            <param name="docs">The full list of Documents.</param>
            <param name="tokenMax">The maximum cumulative length of any subset of Documents.</param>
            <param name="otherKeys">Arbitrary additional keyword params to pass to each call of the length_func.</param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.ReduceDocumentsChain.CollapseDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Execute a collapse function on a set of documents and merge their metadatas.
            </summary>
            <param name="docs">A list of Documents to combine.</param>
            <param name="otherKeys">Arbitrary additional keyword params to pass to each call of the combine_document_func.</param>
            <returns>
            A single Document with the output of combine_document_func for the page content
            and the combined metadata's of all the input documents. All metadata values
            are strings, and where there are overlapping keys across documents the
            values are joined by ", "
            </returns>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CombineDocumentsChain">
            <summary>
            Final chain to call to combine documents.
            This is typically a StuffDocumentsChain.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.CollapseDocumentsChain">
            <summary>
            Chain to use to collapse documents if needed until they can all fit.
            If null, will use the combine_documents_chain.
            This is typically a StuffDocumentsChain.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.ReduceDocumentsChainInput.TokenMax">
            <summary>
            The maximum number of tokens to group documents into. For example, if
            set to 3000 then documents will be grouped into chunks of no greater than
            3000 tokens before trying to combine them into a smaller chunk.
            </summary>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.StuffDocumentsChain">
            <summary>
            Chain that combines documents by stuffing into context.
            
            This chain takes a list of documents and first combines them into a single string.
            It does this by formatting each document into a string with the `document_prompt`
            and then joining them together with `document_separator`. It then adds that new
            string to the inputs with the variable name set by `document_variable_name`.
            Those inputs are then passed to the `LlmChain`.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChain.LlmChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.StuffDocumentsChain.#ctor(LangChain.Chains.CombineDocuments.StuffDocumentsChainInput)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.StuffDocumentsChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.StuffDocumentsChain.CombineDocsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.StuffDocumentsChain.PromptLength(System.Collections.Generic.IReadOnlyList{LangChain.Docstore.Document},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput.#ctor(LangChain.Chains.LLM.ILlmChain)">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput.LlmChain">
            <summary>
            LLM chain which is called with the formatted document string, along with any other inputs.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput.DocumentPrompt">
            <summary>
            Template to use to format each document, gets passed to `format_document`.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput.DocumentVariableName">
            <summary>
            The variable name in the LlmChain to put the documents in.
            If only one variable in the llm_chain, this need not be provided.
            </summary>
        </member>
        <member name="P:LangChain.Chains.CombineDocuments.StuffDocumentsChainInput.DocumentSeparator">
            <summary>
            The string with which to join the formatted documents
            </summary>
        </member>
        <member name="T:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain">
            <summary>
            Chain for chatting with an index.
            </summary>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain.#ctor(LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput)">
            <summary>
            Chain for chatting with an index.
            </summary>
        </member>
        <member name="F:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain._fields">
            <summary> Chain input fields </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChain.GetDocsAsync(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Get docs.
            </summary>
            <param name="question"></param>
            <param name="inputs"></param>
            <param name="runManager"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.#ctor(LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain,LangChain.Chains.LLM.ILlmChain)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.CombineDocsChain">
            <summary>
            The chain used to combine any retrieved documents.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.QuestionGenerator">
             <summary>
             The chain used to generate a new question for the sake of retrieval.
            
             This chain will take in the current question (with variable `question`)
             and any chat history (with variable `chat_history`) and will produce
             a new standalone question to be used later on.
             </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.OutputKey">
            <summary>
            The output key to return the final answer of this chain in.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.RephraseQuestion">
             <summary>
             Whether or not to pass the new generated question to the combine_docs_chain.
            
             If True, will pass the new generated question along.
             If False, will only use the new generated question for retrieval and pass the
             original question along to the <see cref="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.CombineDocsChain"/>.
             </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.ReturnSourceDocuments">
            <summary>
            Return the retrieved source documents as part of the final result.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.ReturnGeneratedQuestion">
            <summary>
            Return the generated question as part of the final result.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.GetChatHistory">
            <summary>
            An optional function to get a string of the chat history.
            If None is provided, will use a default.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.ResponseIfNoDocsFound">
            <summary>
            If specified, the chain will return a fixed response if no docs 
            are found for the question.
            </summary>
        </member>
        <member name="T:LangChain.Chains.ConversationalRetrieval.ChatTurnTypeHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ChatTurnTypeHelper.GetChatHistory(System.Collections.Generic.IReadOnlyList{LangChain.Providers.Message})">
            <summary>
            
            </summary>
            <param name="chatHistory"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChain">
            <summary>
            Chain for having a conversation based on retrieved documents.
            
            This chain takes in chat history (a list of messages) and new questions,
            and then returns an answer to that question.
            The algorithm for this chain consists of three parts:
            
            1. Use the chat history and the new question to create a "standalone question".
            This is done so that this question can be passed into the retrieval step to fetch
            relevant documents. If only the new question was passed in, then relevant context
            may be lacking. If the whole conversation was passed into retrieval, there may
            be unnecessary information there that would distract from retrieval.
            
            2. This new question is passed to the retriever and relevant documents are
            returned.
            
            3. The retrieved documents are passed to an LLM along with either the new question
            (default behavior) or the original question and chat history to generate a final
            response.
            </summary>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChain.#ctor(LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChainInput)">
            <summary>
            Chain for having a conversation based on retrieved documents.
            
            This chain takes in chat history (a list of messages) and new questions,
            and then returns an answer to that question.
            The algorithm for this chain consists of three parts:
            
            1. Use the chat history and the new question to create a "standalone question".
            This is done so that this question can be passed into the retrieval step to fetch
            relevant documents. If only the new question was passed in, then relevant context
            may be lacking. If the whole conversation was passed into retrieval, there may
            be unnecessary information there that would distract from retrieval.
            
            2. This new question is passed to the retriever and relevant documents are
            returned.
            
            3. The retrieved documents are passed to an LLM along with either the new question
            (default behavior) or the original question and chat history to generate a final
            response.
            </summary>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChain.GetDocsAsync(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},LangChain.Callback.CallbackManagerForChainRun)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChain.ReduceTokensBelowLimit(System.Collections.Generic.IEnumerable{LangChain.Docstore.Document})">
            <summary>
            
            </summary>
            <param name="docs"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChainInput">
            <summary>
            
            </summary>
            <param name="retriever"></param>
            <param name="combineDocsChain"></param>
            <param name="questionGenerator"></param>
        </member>
        <member name="M:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChainInput.#ctor(LangChain.Retrievers.BaseRetriever,LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain,LangChain.Chains.LLM.ILlmChain)">
            <summary>
            
            </summary>
            <param name="retriever"></param>
            <param name="combineDocsChain"></param>
            <param name="questionGenerator"></param>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChainInput.Retriever">
            <summary>
            Retriever to use to fetch documents.
            </summary>
        </member>
        <member name="P:LangChain.Chains.ConversationalRetrieval.ConversationalRetrievalChainInput.MaxTokensLimit">
            <summary>
            If set, enforces that the documents returned are less than this limit.
            This is only enforced if <see cref="P:LangChain.Chains.ConversationalRetrieval.BaseConversationalRetrievalChainInput.CombineDocsChain"/> is of type <see cref="T:LangChain.Chains.CombineDocuments.StuffDocumentsChain"/>.
            </summary>
        </member>
        <member name="T:LangChain.Chains.LLM.ILlmChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.LLM.ILlmChain.Predict(LangChain.Schema.ChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.LLM.ILlmChain.ApplyAsync(System.Collections.Generic.IReadOnlyList{LangChain.Schema.ChainValues})">
            <summary>
            
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.LLM.ILlmChainInput">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.ILlmChainInput.Prompt">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.ILlmChainInput.Llm">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.ILlmChainInput.OutputKey">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.LLM.LlmChain">
            <summary>
            
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.#ctor(LangChain.Chains.LLM.LlmChainInput)">
            <summary>
            
            </summary>
            <param name="fields"></param>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Prompt">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Llm">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.OutputKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.ReturnFinalOnly">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.OutputParser">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.CallbackManager">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Verbose">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Callbacks">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Tags">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.Metadata">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.GetFinalOutput(System.Collections.Generic.List{LangChain.Schema.Generation},LangChain.Schema.BasePromptValue,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            
            </summary>
            <param name="generations"></param>
            <param name="promptValue"></param>
            <param name="runManager"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Execute the chain.
            </summary>
            <param name="values">The values to use when executing the chain.</param>
            <param name="runManager"></param>
            <returns>The resulting output <see cref="T:LangChain.Schema.ChainValues"/>.</returns>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.ApplyAsync(System.Collections.Generic.IReadOnlyList{LangChain.Schema.ChainValues})">
            <summary>
            Call the chain on all inputs in the list.
            </summary>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.PreparePromptsAsync(System.Collections.Generic.IReadOnlyList{LangChain.Schema.ChainValues},LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Prepare prompts from inputs.
            </summary>
            <param name="inputList"></param>
            <param name="runManager"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.CreateOutputs(LangChain.Schema.LlmResult)">
            <summary> Create outputs from response. </summary>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChain.Predict(LangChain.Schema.ChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.LLM.LlmChainInput">
            <summary>
            
            </summary>
            <param name="llm"></param>
            <param name="prompt"></param>
            <param name="memory"></param>
        </member>
        <member name="M:LangChain.Chains.LLM.LlmChainInput.#ctor(LangChain.Providers.IChatModel,LangChain.Prompts.Base.BasePromptTemplate,LangChain.Memory.BaseMemory)">
            <summary>
            
            </summary>
            <param name="llm"></param>
            <param name="prompt"></param>
            <param name="memory"></param>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChainInput.Prompt">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChainInput.Llm">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChainInput.OutputKey">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChainInput.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.LlmChainInput.ReturnFinalOnly">
            <summary>
            Whether to return only the final parsed result. Defaults to True.
            If false, will return a bunch of extra information about the generation.
            </summary>
        </member>
        <member name="T:LangChain.Chains.LLM.SerializedLlmChain">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.LLM.SerializedLlmChain.Llm">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.LLM.SerializedLlmChain.Prompt">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain">
            <summary>
            Base class for question-answering chains.
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.#ctor(LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput)">
            <summary>
            Base class for question-answering chains.
            </summary>
            <param name="fields"></param>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.CallbackManager">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Run get_relevant_text and llm on input query.
            
            If chain has 'return_source_documents' as 'True', returns
            the retrieved documents as well under the key 'source_documents'.
            </summary>
            <param name="values"></param>
            <param name="runManager"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.BaseRetrievalQaChain.GetDocsAsync(System.String,LangChain.Callback.CallbackManagerForChainRun)">
            <summary>
            Get documents to do question answering over.
            </summary>
            <param name="question"></param>
            <param name="runManager"></param>
        </member>
        <member name="T:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput">
            <summary>
            
            </summary>
            <param name="combineDocumentsChain"></param>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput.#ctor(LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain)">
            <summary>
            
            </summary>
            <param name="combineDocumentsChain"></param>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput.CombineDocumentsChain">
            <summary> Chain to use to combine the documents. </summary>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput.ReturnSourceDocuments">
            <summary> Return the source documents or not. </summary>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput.InputKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.BaseRetrievalQaChainInput.OutputKey">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.RetrievalQA.RetrievalQaChain">
            <summary>
            Chain for question-answering against an index.
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.RetrievalQaChain.#ctor(LangChain.Chains.RetrievalQA.RetrievalQaChainInput)">
            <summary>
            Chain for question-answering against an index.
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.RetrievalQaChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.RetrievalQaChain.GetDocsAsync(System.String,LangChain.Callback.CallbackManagerForChainRun)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.RetrievalQA.RetrievalQaChainInput">
            <summary>
            
            </summary>
            <param name="combineDocumentsChain"></param>
            <param name="retriever"></param>
        </member>
        <member name="M:LangChain.Chains.RetrievalQA.RetrievalQaChainInput.#ctor(LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain,LangChain.Retrievers.BaseRetriever)">
            <summary>
            
            </summary>
            <param name="combineDocumentsChain"></param>
            <param name="retriever"></param>
        </member>
        <member name="P:LangChain.Chains.RetrievalQA.RetrievalQaChainInput.Retriever">
            <summary> Documents retriever. </summary>
        </member>
        <member name="T:LangChain.Chains.Sequentials.SequentialChain">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChain.Chains">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChain.InputKeys">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChain.OutputKeys">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChain.ReturnAll">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.Sequentials.SequentialChain.#ctor(LangChain.Chains.Sequentials.SequentialChainInput)">
            <summary>
            
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:LangChain.Chains.Sequentials.SequentialChain.ChainType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.Sequentials.SequentialChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.CallbackManagerForChainRun)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.Sequentials.SequentialChain.Validate">
            <summary>
            
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:LangChain.Chains.Sequentials.SequentialChainInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.Chains">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.OutputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.ReturnAll">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.Verbose">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.Callbacks">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.Tags">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.Sequentials.SequentialChainInput.Metadata">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.Sequentials.SequentialChainInput.#ctor(LangChain.Abstractions.Chains.Base.IChain[],System.String[],System.String[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="chains"></param>
            <param name="inputVariables"></param>
            <param name="outputVariables"></param>
            <param name="returnAll"></param>
        </member>
        <member name="T:LangChain.Chains.SerializedBaseChain">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.SerializedBaseChain.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.AgentExecutorChain">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.AgentExecutorChain.HistoryKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.AgentExecutorChain.IsObserver">
            <summary>
            Messages of this agent will not be added to the history
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.AgentExecutorChain.#ctor(LangChain.Chains.HelperChains.BaseStackableChain,System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.AgentExecutorChain.SetHistory(System.String)">
            <summary>
            
            </summary>
            <param name="history"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.AgentExecutorChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.AgentTask">
            <summary>
            
            </summary>
            <param name="agent"></param>
            <param name="description"></param>
            <param name="tools"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.AgentTask.#ctor(LangChain.Chains.StackableChains.Agents.Crew.CrewAgent,System.String,System.Collections.Generic.List{LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool})">
            <summary>
            
            </summary>
            <param name="agent"></param>
            <param name="description"></param>
            <param name="tools"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.AgentTask.Agent">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.AgentTask.Tools">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.AgentTask.Description">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.AgentTask.ExecuteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Crew">
            <summary>
            
            </summary>
            <param name="agents"></param>
            <param name="tasks"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Crew.#ctor(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.CrewAgent},System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.AgentTask})">
            <summary>
            
            </summary>
            <param name="agents"></param>
            <param name="tasks"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Crew.RunAsync(System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent">
            <summary>
            
            </summary>
        </member>
        <member name="E:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.ReceivedTask">
            <summary>
            
            </summary>
        </member>
        <member name="E:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.CalledAction">
            <summary>
            
            </summary>
        </member>
        <member name="E:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.ActionResult">
            <summary>
            
            </summary>
        </member>
        <member name="E:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.Answered">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.Role">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.Goal">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.Backstory">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.UseMemory">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.UseCache">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.#ctor(LangChain.Providers.IChatModel,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="role"></param>
            <param name="goal"></param>
            <param name="backstory"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.AddTools(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool})">
            <summary>
            
            </summary>
            <param name="tools"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.Context">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.MaxActions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.CrewAgent.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.CrewChain">
            <summary>
            
            </summary>
            <param name="allAgents"></param>
            <param name="manager"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.CrewChain.#ctor(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.CrewAgent},LangChain.Chains.StackableChains.Agents.Crew.CrewAgent,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="allAgents"></param>
            <param name="manager"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.CrewChain.Context">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.CrewChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Prompts">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.Crew.Prompts.Task">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.Crew.Prompts.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.Crew.Prompts.Role">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.Crew.Prompts.Tools">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.Crew.Prompts.Scratchpad">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.Prompts.TaskExecutionWithMemory">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.Prompts.TaskExecutionWithoutMemory">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Tools.AskQuestionTool">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.AskQuestionTool.#ctor(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.CrewAgent})">
            <summary>
            
            </summary>
            <param name="coworkers"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.AskQuestionTool.ToolTask(System.String,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool.Description">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentTool.ToolTask(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentToolLambda">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentToolLambda.#ctor(System.String,System.String,System.Func{System.String,System.Threading.Tasks.Task{System.String}})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="description"></param>
            <param name="func"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.CrewAgentToolLambda.ToolTask(System.String,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Crew.Tools.DelegateWorkTool">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.DelegateWorkTool.#ctor(System.Collections.Generic.IEnumerable{LangChain.Chains.StackableChains.Agents.Crew.CrewAgent})">
            <summary>
            
            </summary>
            <param name="coworkers"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Crew.Tools.DelegateWorkTool.ToolTask(System.String,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.GroupChat">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.GroupChat.ThrowOnLimit">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.GroupChat.#ctor(System.Collections.Generic.IList{LangChain.Chains.StackableChains.Agents.AgentExecutorChain},System.String,System.Int32,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="agents"></param>
            <param name="stopPhrase"></param>
            <param name="messagesLimit"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.GroupChat.History">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.GroupChat.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.PromptedAgent">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.PromptedAgent.Template">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.PromptedAgent.#ctor(System.String,System.String,LangChain.Providers.IChatModel,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="prompt"></param>
            <param name="model"></param>
            <param name="outputKey"></param>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain.DefaultPrompt">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain.#ctor(LangChain.Providers.IChatModel,System.String,System.Int32,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="reActPrompt"></param>
            <param name="maxActions"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain.UseCache(System.Boolean)">
            <summary>
            
            </summary>
            <param name="enabled"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.ReActAgentExecutorChain.UseTool(LangChain.Chains.StackableChains.Agents.Tools.AgentTool)">
            <summary>
            
            </summary>
            <param name="tool"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Tools.AgentTool">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Tools.AgentTool.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Tools.AgentTool.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Agents.Tools.AgentTool.Description">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Tools.AgentTool.ToolTask(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Agents.Tools.AgentToolLambda">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Tools.AgentToolLambda.#ctor(System.String,System.String,System.Func{System.String,System.Threading.Tasks.Task{System.String}})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="description"></param>
            <param name="func"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Agents.Tools.AgentToolLambda.ToolTask(System.String,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.DoChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.DoChain.#ctor(System.Action{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.DoChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Files.SaveIntoFileChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Files.SaveIntoFileChain.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="filename"></param>
            <param name="inputKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Files.SaveIntoFileChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.Context.ConsoleTraceHook">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Context.ConsoleTraceHook.UseColors">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Context.ConsoleTraceHook.ValuesLength">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.ConsoleTraceHook.ChainStart(LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.ConsoleTraceHook.LinkEnter(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.ConsoleTraceHook.LinkExit(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Context.StackableChainHook">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.StackableChainHook.ChainStart(LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.StackableChainHook.LinkEnter(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <summary>
            
            </summary>
            <param name="chain"></param>
            <param name="values"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.Context.StackableChainHook.LinkExit(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.StackableChains.Context.StackableChainValues)">
            <summary>
            
            </summary>
            <param name="chain"></param>
            <param name="values"></param>
        </member>
        <member name="T:LangChain.Chains.StackableChains.Context.StackableChainValues">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.Context.StackableChainValues.Hook">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Chains.StackableChains.ImageGeneration.ImageGenerationChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ImageGeneration.ImageGenerationChain.#ctor(LangChain.Providers.IImageGenerationModel,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ImageGeneration.ImageGenerationChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.StackableChains.ReAct.ReActParserChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.ReActParserChain.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="inputKey"></param>
            <param name="outputText"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.ReActParserChain.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <returns></returns>
            <exception cref="T:LangChain.Schema.OutputParserException"></exception>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.ReActParserChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.StackableChains.ReAct.AgentAction">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="actionInput"></param>
            <param name="text"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.AgentAction.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="actionInput"></param>
            <param name="text"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.ReAct.AgentAction.Action">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.ReAct.AgentAction.ActionInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.ReAct.AgentAction.Text">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.AgentAction.ToString">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.StackableChains.ReAct.AgentFinish">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="text"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.AgentFinish.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="output"></param>
            <param name="text"></param>
        </member>
        <member name="P:LangChain.Chains.StackableChains.ReAct.AgentFinish.Output">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.StackableChains.ReAct.AgentFinish.Text">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.ReAct.AgentFinish.ToString">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.StackableChains.STTChain">
            <summary>
            Speech to text chain
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.STTChain.#ctor(LangChain.Providers.ISpeechToTextModel,LangChain.Providers.SpeechToTextSettings,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Chains.StackableChains.STTChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Chains.StackableChains.STTChain.UseCache(System.Boolean)">
            <summary>
            
            </summary>
            <param name="enabled"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.TTSChain">
            <summary>
            Text to speech chain
            </summary>
        </member>
        <member name="M:LangChain.Chains.StackableChains.TTSChain.#ctor(LangChain.Providers.ITextToSpeechModel,LangChain.Providers.TextToSpeechSettings,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.TTSChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.StackableChains.TTSChain.UseCache(System.Boolean)">
            <summary>
            
            </summary>
            <param name="enabled"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.StackableChains.UpdateMemoryChain">
            <summary>
            
            </summary>
            <param name="memory"></param>
            <param name="requestKey"></param>
            <param name="responseKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.UpdateMemoryChain.#ctor(LangChain.Memory.BaseChatMemory,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="memory"></param>
            <param name="requestKey"></param>
            <param name="responseKey"></param>
        </member>
        <member name="M:LangChain.Chains.StackableChains.UpdateMemoryChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.HelperChains.BaseStackableChain">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.HelperChains.BaseStackableChain.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.HelperChains.BaseStackableChain.InputKeys">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.HelperChains.BaseStackableChain.OutputKeys">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.#ctor(LangChain.Chains.HelperChains.BaseStackableChain)">
            <summary>
            
            </summary>
            <param name="lastChild"></param>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.GenerateName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.CallAsync(LangChain.Abstractions.Schema.IChainValues,LangChain.Callback.ICallbacks,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="values"></param>
            <param name="callbacks"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:LangChain.Chains.HelperChains.Exceptions.StackableChainException"></exception>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.op_BitwiseOr(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.HelperChains.BaseStackableChain)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.BitwiseOr(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.HelperChains.BaseStackableChain)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.Run(LangChain.Chains.StackableChains.Context.StackableChainHook)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.Run(System.String,LangChain.Chains.StackableChains.Context.StackableChainHook)">
            <summary>
            
            </summary>
            <param name="resultKey"></param>
            <param name="hook"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.Run``1(System.String,LangChain.Chains.StackableChains.Context.StackableChainHook)">
            <summary>
            
            </summary>
            <param name="resultKey"></param>
            <param name="hook"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.Run(System.String)">
            <summary>
            
            </summary>
            <param name="resultKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.BaseStackableChain.Run(System.Collections.Generic.Dictionary{System.String,System.Object},LangChain.Callback.ICallbacks)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="callbacks"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.HelperChains.Exceptions.StackableChainException">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.Exceptions.StackableChainException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.Exceptions.StackableChainException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.Exceptions.StackableChainException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.HelperChains.LLMChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.LLMChain.#ctor(LangChain.Providers.IChatModel,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.LLMChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.LLMChain.UseCache(System.Boolean)">
            <summary>
            
            </summary>
            <param name="enabled"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.HelperChains.PromptChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.PromptChain.#ctor(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.PromptChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.HelperChains.RetrieveDocumentsChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.RetrieveDocumentsChain.#ctor(LangChain.Indexes.VectorStoreIndexWrapper,System.String,System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.RetrieveDocumentsChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.HelperChains.SetChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.SetChain.#ctor(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.HelperChains.SetChain.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.SetChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Chains.HelperChains.SetLambdaChain">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Chains.HelperChains.SetLambdaChain.#ctor(System.Func{System.String},System.String)">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Chains.HelperChains.SetLambdaChain.QueryGetter">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.SetLambdaChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Chains.HelperChains.StackChain">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.#ctor(LangChain.Chains.HelperChains.BaseStackableChain,LangChain.Chains.HelperChains.BaseStackableChain)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.HelperChains.StackChain.IsolatedInputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.HelperChains.StackChain.IsolatedOutputKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.AsIsolated(System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="inputKeys"></param>
            <param name="outputKeys"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.AsIsolated(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.op_RightShift(LangChain.Chains.HelperChains.StackChain,LangChain.Chains.HelperChains.BaseStackableChain)">
            <summary>
            Represents a stack chain.
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StackChain.RightShift(LangChain.Chains.HelperChains.StackChain,LangChain.Chains.HelperChains.BaseStackableChain)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Chains.HelperChains.StuffDocumentsChain">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Chains.HelperChains.StuffDocumentsChain.DocumentsSeparator">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.HelperChains.StuffDocumentsChain.Format">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Chains.HelperChains.StuffDocumentsChain.FormatKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StuffDocumentsChain.#ctor(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StuffDocumentsChain.WithSeparator(System.String)">
            <summary>
            
            </summary>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StuffDocumentsChain.WithFormat(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Chains.HelperChains.StuffDocumentsChain.InternalCall(LangChain.Abstractions.Schema.IChainValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Common.Converters.ObjectAsPrimitiveConverter">
            <inheritdoc />
            According: https://stackoverflow.com/questions/65972825/c-sharp-deserializing-nested-json-to-nested-dictionarystring-object
        </member>
        <member name="M:LangChain.Common.Converters.ObjectAsPrimitiveConverter.#ctor">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Common.Converters.ObjectAsPrimitiveConverter.#ctor(LangChain.Common.Converters.FloatFormat,LangChain.Common.Converters.UnknownNumberFormat,LangChain.Common.Converters.ObjectFormat)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Common.Converters.ObjectAsPrimitiveConverter.Write(System.Text.Json.Utf8JsonWriter,System.Object,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Common.Converters.ObjectAsPrimitiveConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Common.Converters.ObjectAsPrimitiveConverter.CreateDictionary">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:LangChain.Common.Converters.FloatFormat">
            <summary> </summary>
        </member>
        <member name="F:LangChain.Common.Converters.FloatFormat.Double">
            <summary> </summary>
        </member>
        <member name="F:LangChain.Common.Converters.FloatFormat.Decimal">
            <summary> </summary>
        </member>
        <member name="T:LangChain.Common.Converters.UnknownNumberFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Common.Converters.UnknownNumberFormat.Error">
            <summary> </summary>
        </member>
        <member name="F:LangChain.Common.Converters.UnknownNumberFormat.JsonElement">
            <summary> </summary>
        </member>
        <member name="T:LangChain.Common.Converters.ObjectFormat">
            <summary> </summary>
        </member>
        <member name="F:LangChain.Common.Converters.ObjectFormat.Expando">
            <summary> </summary>
        </member>
        <member name="F:LangChain.Common.Converters.ObjectFormat.Dictionary">
            <summary> </summary>
        </member>
        <member name="T:LangChain.Common.DictionaryExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Common.DictionaryExtensions.TryAddKeyValues``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
            <summary>
            Adds key values of additional to target dictionary if key is not yet present in target
            </summary>
            <returns>target dictionary</returns>
        </member>
        <member name="T:LangChain.Docstore.Document">
            <summary>
            Class for storing document
            <remarks>
            - no BaseModel implementation from pydantic
            - ported from langchain/docstore/document.py
            </remarks>
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="content"></param>
            <param name="metadata"></param>
        </member>
        <member name="P:LangChain.Docstore.Document.Empty">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Docstore.Document.PageContent">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Docstore.Document.LookupIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Docstore.Document.LookupStr">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Docstore.Document.Metadata">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.Paragraphs">
            <summary>
            Paragraphs of the page.
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.Summary">
            <summary>
            Summary of the page (the first paragraph)
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.Lookup(System.String)">
            <summary>
            Lookup a term in the page, imitating cmd-F functionality.
            </summary>
        </member>
        <member name="M:LangChain.Docstore.Document.ToString">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Docstore.DocumentExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Docstore.DocumentExtensions.ToDocument(System.String)">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Docstore.DocumentExtensions.ToDocuments(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:LangChain.DocumentLoaders.TextLoader">
            <inheritdoc />
        </member>
        <member name="M:LangChain.DocumentLoaders.TextLoader.#ctor(System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Load text file.
            </summary>
            <param name="filePath">Path to the file to load.</param>
            <param name="encoding">File encoding to use. Null for default</param>
            <param name="autoDetectEncoding">Whether to try to autodetect the file encoding
            if the specified encoding fails.</param>
        </member>
        <member name="M:LangChain.DocumentLoaders.TextLoader.Load">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Indexes.VectorStoreIndexCreator">
            <summary>
            Logic for creating a vectorstore index.
            </summary>
            // embeddings are not needed here because VectorStore already has them
        </member>
        <member name="M:LangChain.Indexes.VectorStoreIndexCreator.#ctor(LangChain.VectorStores.VectorStore,LangChain.Splitters.Text.TextSplitter)">
            <summary>
            Logic for creating a vectorstore index.
            </summary>
            // embeddings are not needed here because VectorStore already has them
        </member>
        <member name="P:LangChain.Indexes.VectorStoreIndexCreator.VectorStore">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Indexes.VectorStoreIndexCreator.TextSplitter">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Indexes.VectorStoreIndexCreator.FromLoaders(System.Collections.Generic.List{LangChain.Base.BaseLoader})">
            <summary>
            Create a vectorstore index from loaders.
            </summary>
        </member>
        <member name="M:LangChain.Indexes.VectorStoreIndexCreator.FromDocumentsAsync(System.Collections.Generic.IReadOnlyCollection{LangChain.Docstore.Document})">
            <summary>
            Create a vectorstore index from documents.
            </summary>
        </member>
        <member name="T:LangChain.Indexes.VectorStoreIndexWrapper">
            <summary>
            
            </summary>
            <param name="vectorStore"></param>
        </member>
        <member name="M:LangChain.Indexes.VectorStoreIndexWrapper.#ctor(LangChain.VectorStores.VectorStore)">
            <summary>
            
            </summary>
            <param name="vectorStore"></param>
        </member>
        <member name="P:LangChain.Indexes.VectorStoreIndexWrapper.Store">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Indexes.VectorStoreIndexWrapper.QueryAsync(System.String,LangChain.Chains.CombineDocuments.BaseCombineDocumentsChain,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="question"></param>
            <param name="llm"></param>
            <param name="inputKey"></param>
            <param name="outputKey"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.LLMS.BaseLlm">
            <inheritdoc />
        </member>
        <member name="M:LangChain.LLMS.BaseLlm.#ctor(LangChain.LLMS.IBaseLlmParams)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.LLMS.BaseLlm.GeneratePrompt(LangChain.Schema.BasePromptValue[],System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            
            </summary>
            <param name="promptValues"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.LLMS.BaseLlm.Generate(System.String[],System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            
            </summary>
            <param name="prompts"></param>
            <param name="stopSequences"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.LLMS.BaseLlm.Call(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Call the LLM using the provided prompt.
            </summary>
            <param name="prompt">The prompt to use.</param>
            <param name="stop">Whether to stop gathering results.</param>
            <returns>A string value containing the LLM response.</returns>
        </member>
        <member name="T:LangChain.LLMS.IBaseLlmCallOptions">
            <inheritdoc />
        </member>
        <member name="T:LangChain.LLMS.IBaseLlmParams">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Memory.BaseChatMemory">
            <summary>
            Abstract base class for chat memory.
            
            NOTE: LangChain's return_messages property is not implemented due to differences between Python and C#
            </summary>
        </member>
        <member name="M:LangChain.Memory.BaseChatMemory.SaveContext(LangChain.Schema.InputValues,LangChain.Schema.OutputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Memory.BaseChatMemory.Clear">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Memory.BaseChatMessageHistory">
            <summary>
            Abstract base class for storing chat message history.
            
            Implementations should over-ride the AddMessages method to handle bulk addition
            of messages.
                
            The default implementation of AddMessages will correctly call AddMessage, so
            it is not necessary to implement both methods.
                
            When used for updating history, users should favor usage of `AddMessages`
            over `AddMessage` or other variants like `AddUserMessage` and `AddAiMessage`
            to avoid unnecessary round-trips to the underlying persistence layer.
            </summary>
        </member>
        <member name="P:LangChain.Memory.BaseChatMessageHistory.Messages">
            <summary>
            A list of messages stored in-memory.
            </summary>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.AddUserMessage(System.String)">
            <summary>
            Convenience method for adding a human message string to the store.
            
            Please note that this is a convenience method.  Code should favor the
            bulk AddMessages interface instead to save on round-trips to the underlying
            persistence layer.
            
            This method may be deprecated in a future release.
            </summary>
            <param name="message">The human message to add</param>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.AddAiMessage(System.String)">
            <summary>
            Convenience method for adding an AI message string to the store.
            
            Please note that this is a convenience method. Code should favor the bulk
            AddMessages interface instead to save on round-trips to the underlying
            persistence layer.
            
            This method may be deprecated in a future release.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.AddMessage(LangChain.Providers.Message)">
            <summary>
            Add a message object to the store.
            </summary>
            <param name="message">A message object to store</param>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.AddMessages(System.Collections.Generic.IEnumerable{LangChain.Providers.Message})">
            <summary>
            Add a list of messages.
            
            Implementations should override this method to handle bulk addition of messages
            in an efficient manner to avoid unnecessary round-trips to the underlying store.
            </summary>
            <param name="messages">A list of message objects to store.</param>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.SetMessages(System.Collections.Generic.IEnumerable{LangChain.Providers.Message})">
            <summary>
            Replace the list of messages.
            
            Implementations should override this method to handle bulk addition of messages
            in an efficient manner to avoid unnecessary round-trips to the underlying store.
            </summary>
            <param name="messages">A list of message objects to store.</param>
        </member>
        <member name="M:LangChain.Memory.BaseChatMessageHistory.Clear">
            <summary>
            Remove all messages from the store
            </summary>
        </member>
        <member name="T:LangChain.Memory.BaseMemory">
            <summary>
            Abstract base class for memory in Chains.
            
            Memory refers to state in Chains.  Memory can be used to store information about
            past executions of a Chain and inject that information into the inputs of
            future executions of the Chain.  For example, for conversational Chains Memory
            can be used to store conversations and automatically add them to future model
            prompts so that the model has the necessary context to respond coherently to
            the latest input.
            </summary>
        </member>
        <member name="P:LangChain.Memory.BaseMemory.MemoryVariables">
            <summary>
            Return key-value pairs given the text input to the chain.
            </summary>
        </member>
        <member name="M:LangChain.Memory.BaseMemory.LoadMemoryVariables(LangChain.Schema.InputValues)">
            <summary>
            The string keys this memory class will add to chain inputs.
            </summary>
            <param name="inputValues"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Memory.BaseMemory.SaveContext(LangChain.Schema.InputValues,LangChain.Schema.OutputValues)">
            <summary>
            Save the context of this chain run to memory.
            </summary>
            <param name="inputValues"></param>
            <param name="outputValues"></param>
        </member>
        <member name="M:LangChain.Memory.BaseMemory.Clear">
            <summary>
            Clear memory contents.
            </summary>
        </member>
        <member name="T:LangChain.Memory.ChatMessageHistory">
            <summary>
            In memory implementation of chat message history.
            
            Stores messages in an in memory list.
            </summary>
        </member>
        <member name="P:LangChain.Memory.ChatMessageHistory.IsMessageAccepted">
            <summary>
            Used to inspect and filter messages on their way to the history store
            NOTE: This is not a feature of python langchain
            </summary>
        </member>
        <member name="P:LangChain.Memory.ChatMessageHistory.Messages">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Memory.ChatMessageHistory.AddMessage(LangChain.Providers.Message)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Memory.ChatMessageHistory.Clear">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Memory.ConversationBufferMemory">
            <summary>
            Buffer for storing conversation memory.
            
            NOTE: LangChain's buffer property is not implemented here
            </summary>
        </member>
        <member name="P:LangChain.Memory.ConversationBufferMemory.MemoryVariables">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationBufferMemory.#ctor">
            <summary>
            Initializes new buffered memory instance
            </summary>
        </member>
        <member name="M:LangChain.Memory.ConversationBufferMemory.#ctor(LangChain.Memory.BaseChatMessageHistory)">
            <summary>
            Initializes new buffered memory instance with provided history store
            </summary>
            <param name="chatHistory">History backing store</param>
        </member>
        <member name="M:LangChain.Memory.ConversationBufferMemory.LoadMemoryVariables(LangChain.Schema.InputValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Memory.ConversationSummaryBufferMemory">
            <summary>
            Buffer with summarizer for storing conversation memory.
            </summary>
        </member>
        <member name="P:LangChain.Memory.ConversationSummaryBufferMemory.MemoryVariables">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.#ctor(LangChain.Providers.IChatModelWithTokenCounting)">
            <summary>
            Initializes new memory instance with provided model and a default history store
            </summary>
            <param name="model">Model to use for summarization</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.#ctor(LangChain.Providers.IChatModelWithTokenCounting,LangChain.Memory.BaseChatMessageHistory)">
            <summary>
            Initializes new memory instance with provided model and history store
            </summary>
            <param name="model">Model to use for summarization</param>
            <param name="chatHistory">History backing store</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.LoadMemoryVariables(LangChain.Schema.InputValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.SaveContext(LangChain.Schema.InputValues,LangChain.Schema.OutputValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.Clear">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryBufferMemory.PruneMessages">
            <summary>
            Prune messages if they exceed the max token limit
            </summary>
            <returns></returns>
        </member>
        <member name="T:LangChain.Memory.ConversationSummaryMemory">
            <summary>
            Conversation summarizer to chat memory.
            </summary>
        </member>
        <member name="P:LangChain.Memory.ConversationSummaryMemory.MemoryVariables">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryMemory.#ctor(LangChain.Providers.IChatModel)">
            <summary>
            Initializes new summarizing memory instance with provided model
            </summary>
            <param name="model">Model to use for summarization</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryMemory.#ctor(LangChain.Providers.IChatModel,LangChain.Memory.BaseChatMessageHistory)">
            <summary>
            Initializes new summarizing memory instance with provided model and history store
            </summary>
            <param name="model">Model to use for summarization</param>
            <param name="chatHistory">History backing store</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryMemory.LoadMemoryVariables(LangChain.Schema.InputValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryMemory.SaveContext(LangChain.Schema.InputValues,LangChain.Schema.OutputValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationSummaryMemory.Clear">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Memory.ConversationWindowBufferMemory">
            <summary>
            Buffer for storing conversation memory.
            
            NOTE: LangChain's buffer property is not implemented here
            </summary>
        </member>
        <member name="P:LangChain.Memory.ConversationWindowBufferMemory.WindowSize">
            <summary>
            Number of messages to store in buffer.
            
            This is actually the number of Human+AI pairs of messages.
            This is the 'k' property in python langchain
            </summary>
        </member>
        <member name="P:LangChain.Memory.ConversationWindowBufferMemory.MemoryVariables">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Memory.ConversationWindowBufferMemory.#ctor">
            <summary>
            Initializes new windowed buffer memory instance
            </summary>
        </member>
        <member name="M:LangChain.Memory.ConversationWindowBufferMemory.#ctor(LangChain.Memory.BaseChatMessageHistory)">
            <summary>
            Initializes new windowed buffer memory instance with provided history store
            </summary>
            <param name="chatHistory">History backing store</param>
        </member>
        <member name="M:LangChain.Memory.ConversationWindowBufferMemory.LoadMemoryVariables(LangChain.Schema.InputValues)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Memory.FileChatMessageHistory">
            <summary>
            Chat message history that stores history in a local file.
            </summary>
        </member>
        <member name="P:LangChain.Memory.FileChatMessageHistory.Messages">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Memory.FileChatMessageHistory.#ctor(System.String)">
            <summary>
            Initializes new history instance with provided file path
            </summary>
            <param name="messagesFilePath">path of the local file to store the messages</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Memory.FileChatMessageHistory.CreateAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Create new history instance with provided file path
            </summary>
            <param name="path">path of the local file to store the messages</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:LangChain.Memory.FileChatMessageHistory.AddMessage(LangChain.Providers.Message)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Memory.FileChatMessageHistory.Clear">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Memory.MemoryExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Memory.MemoryExtensions.WithHistory(System.Collections.Generic.IReadOnlyCollection{LangChain.Providers.Message},LangChain.Memory.BaseMemory)">
            <summary>
            
            </summary>
            <param name="messages"></param>
            <param name="memory"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:LangChain.Prompts.AiMessagePromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.AiMessagePromptTemplate.#ctor(LangChain.Prompts.Base.BaseStringPromptTemplate)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.AiMessagePromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.AiMessagePromptTemplate.FromTemplate(System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.BaseChatPromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.BaseChatPromptTemplate.#ctor(LangChain.Prompts.Base.IBasePromptTemplateInput)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.BaseChatPromptTemplate.FormatMessages(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.BaseChatPromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.BaseChatPromptTemplate.FormatPromptValue(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.BaseMessagePromptTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.BaseMessagePromptTemplate.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.BaseMessagePromptTemplate.FormatMessages(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.BaseMessagePromptTemplate.Serialize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.BaseMessageStringPromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.BaseMessageStringPromptTemplate.#ctor(LangChain.Prompts.Base.BaseStringPromptTemplate)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.BaseMessageStringPromptTemplate.Prompt">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.BaseMessageStringPromptTemplate.InputVariables">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.BaseMessageStringPromptTemplate.Format(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.BaseMessageStringPromptTemplate.FormatMessages(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.Base.BasePromptTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.Base.BasePromptTemplate.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.Base.BasePromptTemplate.PartialVariables">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.#ctor(LangChain.Prompts.Base.IBasePromptTemplateInput)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.AddPartial(LangChain.Schema.PartialValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.MergePartialAndUserVariables(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="userVariables"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.Format(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.FormatPromptValue(LangChain.Schema.InputValues)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.GetPromptType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.Serialize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.Base.BasePromptTemplate.Deserialize(LangChain.Prompts.SerializedBasePromptTemplate)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:LangChain.Prompts.Base.BaseStringPromptTemplate">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Prompts.Base.BaseStringPromptTemplate.FormatPromptValue(LangChain.Schema.InputValues)">
            <inheritdoc />
        </member>
        <member name="M:LangChain.Prompts.Base.BaseStringPromptTemplate.#ctor(LangChain.Prompts.Base.IBasePromptTemplateInput)">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Prompts.Base.IBasePromptTemplateInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.Base.IBasePromptTemplateInput.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.Base.IBasePromptTemplateInput.PartialVariables">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.Base.StringPromptValue">
            <inheritdoc />
        </member>
        <member name="P:LangChain.Prompts.Base.StringPromptValue.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.Base.StringPromptValue.ToChatMessages">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.Base.StringPromptValue.ToString">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.ChatMessagePromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatMessagePromptTemplate.#ctor(LangChain.Prompts.Base.BaseStringPromptTemplate,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.ChatMessagePromptTemplate.Role">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.ChatMessagePromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatMessagePromptTemplate.FromTemplate(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.ChatPromptTemplate">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplate.PromptMessages">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplate.ValidateTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.#ctor(LangChain.Prompts.ChatPromptTemplateInput)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.AddPartial(LangChain.Schema.PartialValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.GetPromptType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.Serialize">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.FormatMessages(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptTemplate.FromPromptMessages(System.Collections.Generic.List{LangChain.Prompts.BaseMessagePromptTemplate})">
            <summary>
            
            </summary>
            <param name="promptMessages"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:LangChain.Prompts.ChatPromptTemplateInput">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplateInput.PromptMessages">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplateInput.ValidateTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplateInput.InputVariables">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptTemplateInput.PartialVariables">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.ChatPromptValue">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptValue.#ctor(System.Collections.Generic.IReadOnlyCollection{LangChain.Providers.Message})">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.ChatPromptValue.Messages">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptValue.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.ChatPromptValue.ToChatMessages">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.HumanMessagePromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.HumanMessagePromptTemplate.#ctor(LangChain.Prompts.Base.BaseStringPromptTemplate)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.HumanMessagePromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.HumanMessagePromptTemplate.FromTemplate(System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.IPromptTemplateInput">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.IPromptTemplateInput.Template">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.IPromptTemplateInput.TemplateFormat">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.IPromptTemplateInput.ValidateTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.LiteralNode">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.LiteralNode.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.LiteralNode.Text">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.ParsedFStringNode">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:LangChain.Prompts.ParsedFStringNode.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:LangChain.Prompts.ParsedFStringNode.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.PromptHelpers">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.PromptHelpers.FormatDocumentAsync(LangChain.Docstore.Document,LangChain.Prompts.Base.BasePromptTemplate)">
             <summary>
             Format a document into a string based on a prompt template.
            
             First, this pulls information from the document from two sources: PageContent and Metadata
             Those are then passed into the `prompt` to produce a formatted string.
             </summary>
             <param name="doc">Document, the PageContent and Metadata will be used to create the final string.</param>
             <param name="prompt">BasePromptTemplate, will be used to format the PageContent and Metadata into the final string.</param>
             <returns> string of the document formatted.</returns>
        </member>
        <member name="T:LangChain.Prompts.PromptTemplate">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.Template">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.TemplateFormat">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.ValidateTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.PartialVariables">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.#ctor(LangChain.Prompts.IPromptTemplateInput)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.GetPromptType">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.FromExamples(System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            
            </summary>
            <param name="examples"></param>
            <param name="suffix"></param>
            <param name="inputVariables"></param>
            <param name="exampleSeparator"></param>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.FromTemplate(System.String,LangChain.Prompts.PromptTemplateInput)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.AddPartial(LangChain.Schema.PartialValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.Serialize">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.Deserialize(LangChain.Prompts.SerializedPromptTemplate)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:LangChain.Prompts.PromptTemplate.Interpolator">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.PromptTemplate.Parser">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.DefaultFormatterMapping">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplate.DefaultParserMapping">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.InterpolateFString(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.InterpolateFStringSafe(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Safer version of <see cref="M:LangChain.Prompts.PromptTemplate.InterpolateFString(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})"/> that will not throw an exception if a variable is missing.
            </summary>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.ParseFString(System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.RenderTemplate(System.String,LangChain.Prompts.TemplateFormatOptions,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="templateFormat"></param>
            <param name="inputValues"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.CheckValidTemplate(System.String,LangChain.Prompts.TemplateFormatOptions,System.Collections.Generic.List{System.String})">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="templateFormatOptions"></param>
            <param name="inputVariables"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplate.ParseTemplate(System.String,LangChain.Prompts.TemplateFormatOptions)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="templateFormat"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.PromptTemplateInput">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.PromptTemplateInput.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplateInput.Template">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplateInput.TemplateFormat">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplateInput.ValidateTemplate">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplateInput.InputVariables">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.PromptTemplateInput.PartialVariables">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Prompts.SerializedBasePromptTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedBasePromptTemplate.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedBasePromptTemplate.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedBasePromptTemplate.Template">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.SerializedMessagePromptTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedMessagePromptTemplate.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedMessagePromptTemplate.InputVariables">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.SerializedMessagePromptTemplate.AdditionalProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.SerializedPromptTemplate">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Prompts.SerializedPromptTemplate.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.SystemMessagePromptTemplate">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.SystemMessagePromptTemplate.#ctor(LangChain.Prompts.Base.BaseStringPromptTemplate)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.SystemMessagePromptTemplate.Format(LangChain.Schema.InputValues)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Prompts.SystemMessagePromptTemplate.FromTemplate(System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Prompts.TemplateFormatOptions">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Prompts.TemplateFormatOptions.FString">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Prompts.TemplateFormatOptions.Jinja2">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Prompts.VariableNode">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Prompts.VariableNode.#ctor(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Prompts.VariableNode.Name">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Retrievers.BaseRetriever">
            <summary>
            Abstract base class for a Document retrieval system.
            
            A retrieval system is defined as something that can take string queries and return
            the most 'relevant' Documents from some source.
            https://api.python.langchain.com/en/latest/_modules/langchain/schema/retriever.html
            </summary>
        </member>
        <member name="P:LangChain.Retrievers.BaseRetriever.Tags">
            <summary>
            Optional list of tags associated with the retriever. Defaults to None
            These tags will be associated with each call to this retriever,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a retriever with its 
            use case.
            </summary>
        </member>
        <member name="P:LangChain.Retrievers.BaseRetriever.Metadata">
            <summary>
            Optional metadata associated with the retriever. Defaults to None
            This metadata will be associated with each call to this retriever,
            and passed as arguments to the handlers defined in `callbacks`.
            You can use these to eg identify a specific instance of a retriever with its 
            use case.
            </summary>
        </member>
        <member name="M:LangChain.Retrievers.BaseRetriever.GetRelevantDocumentsCoreAsync(System.String,LangChain.Callback.CallbackManagerForRetrieverRun)">
            <summary>
            
            </summary>
            <param name="query"></param>
            <param name="runManager"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Retrievers.BaseRetriever.GetRelevantDocumentsAsync(System.String,System.String,LangChain.Callback.ICallbacks,System.Boolean,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Retrieve documents relevant to a query.
            </summary>
            <param name="query">string to find relevant documents for</param>
            <param name="runId"></param>
            <param name="callbacks"></param>
            <param name="verbose"></param>
            <param name="tags"></param>
            <param name="metadata"></param>
            <returns>Relevant documents</returns>
        </member>
        <member name="T:LangChain.Retrievers.WebSearchRetriever">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Retrievers.WebSearchRetriever.#ctor(LangChain.Utilities.IWebSearch,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Retrievers.WebSearchRetriever.GetRelevantDocumentsCoreAsync(System.String,LangChain.Callback.CallbackManagerForRetrieverRun)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Schema.BaseLlmOutputParser`1">
            <summary>
            Abstract base class for parsing the outputs of a model.
            </summary>
        </member>
        <member name="M:LangChain.Schema.BaseLlmOutputParser`1.ParseResult(System.Collections.Generic.IReadOnlyList{LangChain.Schema.Generation},System.Boolean)">
            <summary>
            Parse a list of candidate model Generations into a specific format.
            </summary>
            <param name="result">
                A list of Generations to be parsed. The Generations are assumed
                to be different candidate outputs for a single model input.
            </param>
            <param name="isPartial"></param>
            <returns>Structured output.</returns>
        </member>
        <member name="T:LangChain.Schema.BaseOutputParser`1">
            <summary>
            Base class to parse the output of an LLM call.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LangChain.Schema.BaseOutputParser`1.Parse(System.String)">
            <summary>
            Parse a single string model output into some structure.
            </summary>
            <param name="text">String output of a language model.</param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Schema.BaseOutputParser`1.ParseWithPrompt(System.String,LangChain.Schema.BasePromptValue)">
            <summary>
            Parse the output of an LLM call with the input prompt for context.
            
            The prompt is largely provided in the event the OutputParser wants
            to retry or fix the output in some way, and needs information from
            the prompt to do so.
            </summary>
            <param name="text">String output of a language model.</param>
            <param name="prompt">Input PromptValue.</param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Schema.BaseOutputParser`1.ParseResult(System.Collections.Generic.IReadOnlyList{LangChain.Schema.Generation},System.Boolean)">
            <summary>
            Parse a list of candidate model Generations into a specific format.
            <remarks>
            The return value is parsed from only the first Generation in the result, which
            is assumed to be the highest-likelihood Generation.
            </remarks>
            </summary>
            <param name="result">
            A list of Generations to be parsed. The Generations are assumed
            to be different candidate outputs for a single model input.
            </param>
            <param name="partial"></param>
            <returns>Structured output.</returns>
        </member>
        <member name="M:LangChain.Schema.BaseOutputParser`1.GetFormatInstructions">
            <summary>
            Instructions on how the LLM output should be formatted.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Schema.BaseOutputParser`1.Type">
            <summary>
            
            </summary>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:LangChain.Schema.StrOutputParser">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Schema.StrOutputParser.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Schema.BasePromptValue">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Schema.BasePromptValue.ToChatMessages">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:LangChain.Schema.BasePromptValue.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:LangChain.Schema.ChainValues">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Schema.ChainValues.#ctor(System.Object)">
            <summary>
            
            </summary>
            <param name="getFinalOutput"></param>
        </member>
        <member name="M:LangChain.Schema.ChainValues.#ctor(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="inputKey"></param>
            <param name="value"></param>
        </member>
        <member name="M:LangChain.Schema.ChainValues.#ctor(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:LangChain.Schema.ChainValues.#ctor(LangChain.Schema.ChainValues)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LangChain.Schema.ChainValues.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Schema.ChainValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Schema.ChainValues.Item(System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:LangChain.Schema.ChatGeneration">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Schema.ChatGeneration.Message">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Schema.Generation">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Schema.Generation.Text">
            <summary>
            Generated text output
            </summary>
        </member>
        <member name="P:LangChain.Schema.Generation.GenerationInfo">
            <summary>
            Raw generation info response from the provider.
            May include things like reason for finishing (e.g. in OpenAi)
            </summary>
        </member>
        <member name="T:LangChain.Schema.InputValues">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:LangChain.Schema.InputValues.#ctor(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:LangChain.Schema.InputValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Schema.LlmResult">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Schema.LlmResult.Generations">
            <summary>
            List of the things generated. Each input could have multiple <see cref="T:LangChain.Schema.Generation"/>, hence this is a list of lists.
            </summary>
        </member>
        <member name="P:LangChain.Schema.LlmResult.LlmOutput">
            <summary>
            Dictionary of arbitrary LLM-provider specific output.
            </summary>
        </member>
        <member name="T:LangChain.Schema.OutputParserException">
            <inheritdoc/>
        </member>
        <member name="P:LangChain.Schema.OutputParserException.Output">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Schema.OutputParserException.#ctor(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Schema.OutputParserException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Schema.OutputParserException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.Schema.OutputParserException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Schema.OutputValues">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:LangChain.Schema.OutputValues.#ctor(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:LangChain.Schema.OutputValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Schema.PartialValues">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Schema.PartialValues.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.Schema.PartialValues.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Utilities.DuckDuckGoSearch">
            <summary>
            DuckDuckGo search client
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.TextSearchAsync(System.String,System.String,LangChain.Utilities.DuckDuckGoSearch.SafeSearchType,System.Nullable{LangChain.Utilities.DuckDuckGoSearch.TimeLimit},System.Nullable{System.Int32})">
            <summary>
            DuckDuckGo text search generator. Query params: https://duckduckgo.com/params
            https://github.com/deedy5/duckduckgo_search/blob/main/duckduckgo_search/duckduckgo_search_async.py"
            </summary>
            <param name="keywords">keywords for query</param>
            <param name="region">https://serpapi.com/duckduckgo-regions</param>
            <param name="safeSearch"><see cref="T:LangChain.Utilities.DuckDuckGoSearch.SafeSearchType"/></param>
            <param name="timeLimit"><see cref="T:LangChain.Utilities.DuckDuckGoSearch.TimeLimit"/></param>
            <param name="maxResults">max number of results. If null, returns results only from the first response</param>
            <returns></returns>
            // /// &lt;param name="backend"&gt;
            // /// api, html, lite. Defaults to api.
            // ///     api - collect data from https://duckduckgo.com,
            // ///     html - collect data from https://html.duckduckgo.com,
            // ///     lite - collect data from https://lite.duckduckgo.com.
            // /// &lt;/param&gt;
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.NormalizeUrl(System.String)">
            <summary>
            Unquote URL and replace spaces with '+'
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.NormalizeHtml(System.String)">
            <summary>
            Strip HTML tags from the raw_html string.
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.Sleep">
            <summary>
            Sleep between API requests if proxies is None.
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.GetVqdAsync(System.String)">
            <summary>
            Get vqd value for a search query.
            </summary>
            <param name="keywords"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.Is500InUrl(System.String)">
            <summary>
            something like '506-00.js' inside the url
            </summary>
        </member>
        <member name="T:LangChain.Utilities.DuckDuckGoSearch.TimeLimit">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.TimeLimit.Day">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.TimeLimit.Week">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.TimeLimit.Month">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.TimeLimit.Year">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.Utilities.DuckDuckGoSearch.SafeSearchType">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.SafeSearchType.On">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.SafeSearchType.Moderate">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.Utilities.DuckDuckGoSearch.SafeSearchType.Off">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearch.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:LangChain.Utilities.DuckDuckGoSearchApiWrapper">
            <summary>
            Wrapper for DuckDuckGo Search API.
            
            Free and does not require any setup.
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearchApiWrapper.#ctor(System.String,LangChain.Utilities.DuckDuckGoSearch.SafeSearchType,LangChain.Utilities.DuckDuckGoSearch.TimeLimit,System.Int32)">
            <summary>
            Wrapper for DuckDuckGo Search API.
            
            Free and does not require any setup.
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearchApiWrapper.RunAsync(System.String)">
            <summary>
            Get aggregated search result
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearchApiWrapper.GetSnippetsAsync(System.String)">
            <summary>
            Run query through DuckDuckGo and return concatenated results.
            </summary>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearchApiWrapper.ResultsAsync(System.String,System.Int32)">
            <summary>
            Run query through DuckDuckGo and return metadata.
            </summary>
            <remarks>
            Only "api" backend supported
            </remarks>
            <param name="query">The query to search for.</param>
            <param name="numResults">The number of results to return.</param>
            <returns>
            A list of items with the following props:
                title - The description of the result.
                snippet - The title of the result.
                link - The link to the result.
            </returns>
        </member>
        <member name="M:LangChain.Utilities.DuckDuckGoSearchApiWrapper.Dispose">
            <inheritdoc />
        </member>
        <member name="T:LangChain.Utilities.IWebSearch">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.Utilities.IWebSearch.RunAsync(System.String)">
            <summary>
            
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.Utilities.IWebSearch.ResultsAsync(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="query"></param>
            <param name="numResults"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.Utilities.WebSearchResult">
            <summary>
            
            </summary>
            <param name="Title"></param>
            <param name="Body"></param>
            <param name="Link"></param>
        </member>
        <member name="M:LangChain.Utilities.WebSearchResult.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="Title"></param>
            <param name="Body"></param>
            <param name="Link"></param>
        </member>
        <member name="P:LangChain.Utilities.WebSearchResult.Title">
            <summary></summary>
        </member>
        <member name="P:LangChain.Utilities.WebSearchResult.Body">
            <summary></summary>
        </member>
        <member name="P:LangChain.Utilities.WebSearchResult.Link">
            <summary></summary>
        </member>
        <member name="T:LangChain.VectorStores.ESearchType">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.VectorStores.ESearchType.Similarity">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.VectorStores.ESearchType.SimilarityScoreThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="F:LangChain.VectorStores.ESearchType.MMR">
            <summary>
            
            </summary>
        </member>
        <member name="T:LangChain.VectorStores.VectorStore">
            <summary>
            VectorStore. Check https://api.python.langchain.com/en/latest/_modules/langchain/schema/vectorstore.html
            </summary>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.#ctor(LangChain.Providers.IEmbeddingModel,System.Func{System.Single,System.Single})">
            <summary>
            VectorStore. Check https://api.python.langchain.com/en/latest/_modules/langchain/schema/vectorstore.html
            </summary>
        </member>
        <member name="P:LangChain.VectorStores.VectorStore.EmbeddingModel">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.VectorStores.VectorStore.OverrideRelevanceScoreFn">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.AddDocumentsAsync(System.Collections.Generic.IEnumerable{LangChain.Docstore.Document},System.Threading.CancellationToken)">
            <summary>
            Run more documents through the embeddings and add to the vectorstore.
            </summary>
            <param name="documents">Documents to add to the vectorstore.</param>
            <param name="cancellationToken"></param>
            <returns>List of Ids of the added texts.</returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.AddTextsAsync(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Threading.CancellationToken)">
            <summary>
            Run more texts through the embeddings and add to the vectorstore.
            </summary>
            <param name="texts">List of strings to add to the vectorstore.</param>
            <param name="metadatas">Optional list of metadatas associated with the texts.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Delete by ids
            </summary>
            <param name="ids">List of Ids to delete</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SimilaritySearchAsync(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Return docs most similar to query.
            </summary>
            <param name="query"></param>
            <param name="k"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SimilaritySearchByVectorAsync(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Return docs most similar to embedding vector.
            </summary>
            <param name="embedding">Embedding to look up documents similar to.</param>
            <param name="k">Number of Documents to return. Defaults to 4.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SimilaritySearchWithScoreAsync(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Performs a similarity search with scores.
            </summary>
            <param name="query">The query string.</param>
            <param name="k">The number of results to return.</param>
            <param name="cancellationToken"></param>
            <returns>A list of tuples containing the document and its score.</returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SimilaritySearchWithRelevanceScoresCore(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Default similarity search with relevance scores. Modify if necessary in subclass.
            </summary>
            <param name="query">The query string.</param>
            <param name="k">The number of results to return.</param>
            <param name="cancellationToken"></param>
            <returns>A list of tuples containing the document and its relevance score.</returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SimilaritySearchWithRelevanceScores(System.String,System.Int32,System.Nullable{System.Single},System.Threading.CancellationToken)">
            <summary>
            Return docs and relevance scores in the range [0, 1].
            0 is dissimilar, 1 is most similar.
            </summary>
            <param name="query">input text</param>
            <param name="k">Number of Documents to return. Defaults to 4.</param>
            <param name="scoreThreshold">a floating point value between 0 to 1 to filter the resulting set of retrieved docs</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.MaxMarginalRelevanceSearchByVector(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Int32,System.Single,System.Threading.CancellationToken)">
            <summary>
            Return docs selected using the maximal marginal relevance.
            
            Maximal marginal relevance optimizes for similarity to query AND diversity among selected documents.
            </summary>
            <param name="embedding">Embedding to look up documents similar to.</param>
            <param name="k">Number of Documents to return. Defaults to 4.</param>
            <param name="fetchK">Number of Documents to fetch to pass to MMR algorithm.</param>
            <param name="lambdaMult"> Number between 0 and 1 that determines the degree
            of diversity among the results with 0 corresponding
            to maximum diversity and 1 to minimum diversity.
            Defaults to 0.5.</param>
            <param name="cancellationToken"></param>
            <returns>List of Documents selected by maximal marginal relevance.</returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.MaxMarginalRelevanceSearch(System.String,System.Int32,System.Int32,System.Single,System.Threading.CancellationToken)">
            <summary>
            Return docs selected using the maximal marginal relevance.
            
            Maximal marginal relevance optimizes for similarity to query AND diversity among selected documents.
            </summary>
            <param name="query">Set to look up documents similar to.</param>
            <param name="k">Number of Documents to return. Defaults to 4.</param>
            <param name="fetchK">Number of Documents to fetch to pass to MMR algorithm.</param>
            <param name="lambdaMult"> Number between 0 and 1 that determines the degree
            of diversity among the results with 0 corresponding
            to maximum diversity and 1 to minimum diversity.
            Defaults to 0.5.</param>
            <param name="cancellationToken"></param>
            <returns>List of Documents selected by maximal marginal relevance.</returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SearchAsync(System.String,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Return docs most similar to query using specified search type.
            </summary>
            <param name="query"></param>
            <param name="searchType"></param>
            <param name="k">Number of Documents to return. Defaults to 4.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.EuclideanRelevanceScoreFn(System.Single)">
            <summary>
            Return a similarity score on a scale [0, 1].
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.CosineRelevanceScoreFn(System.Single)">
            <summary>
            
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.MaxInnerProductRelevanceScoreFn(System.Single)">
            <summary>
            
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStore.SelectRelevanceScoreFn">
            <summary>
            The 'correct' relevance function
            may differ depending on a few things, including:
            - the distance / similarity metric used by the VectorStore
            - the scale of your embeddings (OpenAI's are unit normed. Many others are not!)
            - embedding dimensionality
            - etc.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:LangChain.VectorStores.VectorStoreExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreExtensions.AsRetriever(LangChain.VectorStores.VectorStore,LangChain.VectorStores.ESearchType,System.Nullable{System.Single})">
            <summary>
            Return vector store as retriever
            </summary>
            <param name="store">vector store</param>
            <param name="searchType">search type</param>
            <param name="scoreThreshold">score threshold</param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreExtensions.GetSimilarDocuments(LangChain.VectorStores.VectorStore,System.String,System.Int32,LangChain.VectorStores.ESearchType,System.Nullable{System.Single})">
            <summary>
            Return vector store as retriever
            </summary>
            <param name="store">vector store</param>
            <param name="query"></param>
            <param name="amount"></param>
            <param name="searchType">search type</param>
            <param name="scoreThreshold">score threshold</param>
            <returns></returns>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreExtensions.AsString(System.Collections.Generic.IEnumerable{LangChain.Docstore.Document},System.String)">
            <summary>
            
            </summary>
            <param name="documents"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="T:LangChain.VectorStores.VectorStoreRetriever">
            <summary>
            Base Retriever class for VectorStore.
            https://api.python.langchain.com/en/latest/_modules/langchain/schema/vectorstore.html
            </summary>
        </member>
        <member name="P:LangChain.VectorStores.VectorStoreRetriever.Vectorstore">
            <summary>
            
            </summary>
        </member>
        <member name="P:LangChain.VectorStores.VectorStoreRetriever.K">
            <summary>
            
            </summary>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreRetriever.#ctor(LangChain.VectorStores.VectorStore,LangChain.VectorStores.ESearchType,System.Nullable{System.Single})">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreRetriever.GetRelevantDocumentsCoreAsync(System.String,LangChain.Callback.CallbackManagerForRetrieverRun)">
            <inheritdoc/>
        </member>
        <member name="M:LangChain.VectorStores.VectorStoreRetriever.AddDocumentsAsync(System.Collections.Generic.IEnumerable{LangChain.Docstore.Document})">
            <summary>
            
            </summary>
            <param name="documents"></param>
            <returns></returns>
        </member>
    </members>
</doc>
